# NEANDER-X LCC Backend v3.0

This directory contains the LCC compiler backend for the NEANDER-X 8-bit educational processor.

## Overview

The NEANDER-X is an 8-bit accumulator-based processor designed for educational purposes. This LCC backend generates optimized assembly code using the full LCC Extension Instruction Set.

## Version 3.0 Features

This version uses the complete LCC Extension instructions for optimal code generation:

| Instruction | Old Approach | New Approach | Improvement |
|-------------|--------------|--------------|-------------|
| Add reg+reg | TAX, POP, STA _tmp, TXA, ADD _tmp | TAX, POP, ADDX | 40% fewer cycles |
| Sub reg-reg | 6 instructions + 2 memory ops | SWPX, POP, SUBX | 66% fewer cycles |
| AND/OR/XOR reg | 4 instructions + memory | TAX, POP, ANDX/ORX/XORX | 50% fewer cycles |
| Compare imm | LDI, STA _tmp, LDA, CMP _tmp | CMPI imm | 75% fewer cycles |
| Multiply imm | LDXI imm, MUL | MULI imm | Single instruction |
| Divide imm | LDXI imm, DIV | DIVI imm | Single instruction |
| Pointer deref | Complex multi-step | LDA (addr) | Single instruction |
| Indexed indirect | Complex multi-step | LDA (addr),Y | 2 instructions |
| Shift loop counter | TXA, DEC, TAX | DEX | 66% fewer cycles |

## Type Sizes

| Type | Size | Notes |
|------|------|-------|
| char | 1 byte | Native size |
| short | 1 byte | Limited to 8-bit |
| int | 1 byte | Native size |
| long | 2 bytes | Uses ADC/SBC |
| pointer | 2 bytes | 16-bit address space |
| float | N/A | Not supported |
| double | N/A | Not supported |

## Register Usage

| Register | Usage |
|----------|-------|
| AC | Accumulator - primary computation register |
| X | Index register - array indexing, MUL/DIV operand |
| Y | Index register - MUL high byte, DIV remainder, second index |
| FP | Frame pointer - local variable access (16-bit) |
| SP | Stack pointer - implicit management (16-bit) |
| PC | Program counter (16-bit) |

## Instructions Used by the Backend

### Register-to-Register ALU (No Memory Traffic)
- `ADDX` - AC = AC + X
- `SUBX` - AC = AC - X
- `ANDX` - AC = AC & X
- `ORX` - AC = AC | X
- `XORX` - AC = AC ^ X

### Immediate Operations
- `CMPI imm` - Compare AC with immediate (sets flags)
- `MULI imm` - AC = AC * imm (Y gets high byte)
- `DIVI imm` - AC = AC / imm (Y gets remainder)

### Indirect Addressing (Pointer Operations)
- `LDA (addr)` - Load from address stored at addr (*ptr)
- `STA (addr)` - Store to address stored at addr (*ptr = val)
- `LDA (addr),Y` - Indirect indexed (ptr[i])

### Register Operations
- `SWPX` - Swap AC and X (for operand reordering)
- `SWPY` - Swap AC and Y
- `DEX` - Decrement X (for loop counters)
- `DEY` - Decrement Y

### Standard Instructions
All original NEANDER-X instructions including:
- Memory: LDA, STA, LDA addr,X, LDA addr,Y, LDA addr,FP
- Arithmetic: ADD, SUB, ADC, SBC, MUL, DIV, MOD, INC, DEC, NEG
- Bitwise: AND, OR, XOR, NOT, SHL, SHR, ASR
- Compare: CMP
- Jumps: JMP, JZ, JNZ, JN, JC, JNC, JLE, JGT, JGE, JBE, JA
- Stack: PUSH, POP, PUSH_FP, POP_FP, TSF, TFS
- Calls: CALL, RET

## Calling Convention

- Arguments are pushed right-to-left on the stack
- 8-bit return values are in AC
- 16-bit return values: low byte in AC, high byte in Y
- Caller cleans up arguments
- FP-relative addressing for parameters and locals

### Stack Frame Layout

```
High addresses
+----------------+
| Argument N     | [FP + N+3]
| ...            |
| Argument 1     | [FP + 4]
+----------------+
| Return Addr Hi | [FP + 3]
| Return Addr Lo | [FP + 2]
+----------------+
| Saved FP Hi    | [FP + 1]
| Saved FP Lo    | [FP + 0] <- FP points here
+----------------+
| Local 1        | [FP - 1]
| Local 2        | [FP - 2]
| ...            |
+----------------+ <- SP
Low addresses
```

## Building

```bash
# Build lburg first
cd lburg
make

# Build the compiler with NEANDER-X backend
cd ..
make BUILDDIR=build TARGET=neanderx HOSTFILE=etc/neanderx.c

# Or manually:
./build/lburg src/neanderx.md > build/neanderx.c
cc -c -Isrc -o build/neanderx.o build/neanderx.c
```

## Usage

```bash
# Compile to assembly
./build/rcc -target=neanderx test.c > test.s

# Or with the driver:
./build/lcc -Wf-target=neanderx -S test.c
```

## Test Programs

See the `tst/` directory for example programs:

- `test_basic.c` - Basic arithmetic and function calls
- `test_control.c` - Control flow (if/else, while, recursion)
- `test_array.c` - Arrays and multiplication/division

## Assembly Output Format

The generated assembly uses NEANDER-X mnemonics with v3.0 optimizations:

```asm
; NEANDER-X Assembly
; Generated by LCC v3.0 - Full LCC Extension Instruction Set
; Uses: ADDX/SUBX/ANDX/ORX/XORX, CMPI, MULI/DIVI, LDA()/STA(), DEX/DEY, SWPX/SWPY

; Function: add_values
_add_values:
    ; Prologue
    PUSH_FP         ; Save caller's FP
    TSF             ; FP = SP

    ; Optimized: a + b using ADDX instead of memory temp
    LDA 4,FP        ; Load parameter a
    TAX             ; Save to X
    LDA 5,FP        ; Load parameter b
    ADDX            ; AC = a + b (no memory access!)

    ; Epilogue
    TFS             ; SP = FP
    POP_FP          ; Restore FP
    RET             ; Return
```

## Code Size Improvements

Typical code size reduction with v3.0:

| Operation | v2.0 Size | v3.0 Size | Reduction |
|-----------|-----------|-----------|-----------|
| a + b | 5 instructions | 3 instructions | 40% |
| a - b | 7 instructions | 3 instructions | 57% |
| a == 5 | 4 instructions | 2 instructions | 50% |
| *ptr | 4+ instructions | 1 instruction | 75%+ |
| ptr[i] | 6+ instructions | 2 instructions | 66%+ |

## Limitations

1. **No floating-point support** - The NEANDER-X has no FPU
2. **8-bit native operations** - 16/32-bit ops require multiple instructions
3. **Single accumulator** - Complex expressions may need temp storage
4. **Limited indirect function calls** - Only direct CALL addr supported

## See Also

- [NEANDER-X CPU Documentation](../../README.md)
- [LCC Backend Guide](../../docs/LCC_NEANDER_BACKEND.md)
- [LCC Compiler Reference](../../docs/LCC_COMPILER_COMPLETE.md)
